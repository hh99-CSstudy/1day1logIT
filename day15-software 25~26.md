**"여생의 대부분을 내가 작성한 프로그램의 에러를 찾아내는 데 쓰게 될 것 같다는 깨달음이 강하게 밀려왔다"
-모리스 윌크스,1985-**
# 알고리즘
>1. 추상적이고 이상적인 절차를 기술한 것으로, 구현에 필요한 세부사항과 현실적인 고려사항을 무시한다.
2. 정확하고 명료한 레시피이다.
3. 의미가 완전히 알려져 있고 구체적으로 명시된 기본 연산으로 표현된다.
4. 기본 연산을 사용하여 각 단계를 상세히 설명하고 모든 가능한 상황을 다룬다.
결국 알고리즘은 멈춰야 한다


# 프로그램
> 1.추상적인 것과는 거리가 멀다.
2.실제 컴퓨터가 과제를 완료하기 위해 수행해야 하는 모든 단계를 구체적으로 서술한다.
3.알고리즘과 프로그램 간의 차이는 청사진과 건물 간의 차이와 비슷하다.
4.한쪽은 이상적인 것이고, 다른쪽은 실재하는 것이다.

### **따라서 알고리즘이 이상적인 요리 레시피이면, 프로그램은 적군의 공격을 받는 동안 군인들이 먹을 1개월치 식사를 로봇에게 준비하도록 하는 상세한 명령어 모음이라고 할수 있다**

# 어셈블러
![](https://velog.velcdn.com/images/mocakosan/post/896a5a6c-2e0a-4d84-8e9b-9ac1d489963e/image.png)
## 어셈블러의 역할
> 1.어셈블러는 번역하는 과정에서 필요한 모든 정보를 데이터베이스에 저장하고 필요 시 불러 사용한다.
2.어셈블리어로 작성된 소스 프로그램을 기계어(0,1로 구성된언어)로 번역하고 로더(실행가능한 파일로 만드는 프로그램)에 필요한 정보를 생성하는 역할을 한다.

## 어셈블러의 기능
![](https://velog.velcdn.com/images/mocakosan/post/94cbbdcd-5745-4a98-abde-8a8e0c57afae/image.png)

## 어셈블러의 번역 방법

### _단일 패스 어셈블러_
> 원시 프로그램을 한번에 검색하여 일괄적으로 기걔어 코드로 변경한다.
잘못된 명령어를 사용하는 경우에는 실행할 수 없는 파일을 만든다.
> >#### 단일 어셈블러의 특징
> 1.기호 테이블을 정의한다
2.한번에 번역하기 떄문에  실행 속도가 빠르다.
3.프로그램 작성이 어렵다.
4.프로그램 크기가 작다.

#### 이중 패스 어셈블러
> 원시 프로그램을 1차 검색하여 명령어 및 기호 번지들을 데이터베이스 테이블에 저장한다.
또한 잘못 사용한 명령어나 기호 번지는 프로그래머가 수정할 수 있도록 오류 메시지를 출력한다.
각 테이블에 저장된 정보들을 이용하여 기계어 코드나 기억장소를 변환 한다.
>>이중 패스 어셈블러의 특징
1.기호테이블을 이용하여 목적 프로그램을 생성한다.
2.기호를 정의하기 전에 사용할 수 있어 프로그램 작성이 용이합니다.
3.대부분 어셈블러는 2-pass 어셈블러를 사용한다.
4.두번의 번역 과정을 거치기 때문에 단일 패스 어셈블러에 비해 실행 속도가 느리다.
5.별도의 다른 코드와 결합할 수 있다.
6.프로그램의 크기가 크다.

## 어셈블러의 장점
> 1.프로그래머가 기계어로 작성하지 않아도 어셈블리어로 작성한 원시 프로그램을 기계어로 번역해 준다.
2.어셈블리어로 작성된 원시 프로그램은 기계어보다 읽고, 이해하기가 쉽다.
3.프로그램에 데이터를 사용하기 쉽다.
